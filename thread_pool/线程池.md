# 关于线程池

1. 设计思路

   线程池是这个项目中第一个开始编写的组件，主要内容：

   - 采用多对多的生产者—消费者模型作为内部结构，通过一个线程安全的阻塞队列来实现。队列使用结构为：`std::queue`，保证线程安全并增加阻塞特性的方式为：`std::mutex`+`std::condition_variable`
   - 为了保证该线程池的复用性，我采用了模板表示线程池中的任务，结合可变模版参数和`std::future`实现了完备的模板泛化。这算是我第一次实践泛型编程，整个类的实现中在这里花费的时间最多，最后的成果：
     - 这个线程池可以获取任意形式、任意返回值、任意参数的函数作为传入值（通过模板）
     - 最后如果有需要的话还可以获取线程完成任务后的返回值（通过future）
   - 最后是关于析构，我对该线程池的析构定义为：在线程池析构时，它会在队列中所有已存在的任务都被执行完后，回收所有的子线程

2. 设计抉择点

   在设计线程池的过程中，经历过一些思考和抉择，下面记录一下：

   - 第一点是关于生产者—消费者模型，在这点上我主要权衡的点是：应该通过何种方式来实现阻塞的特性。可选择的方式主要是信号量和条件变量，事实上，这两种实现方式非常的相似，所以我思考了很久应该用哪一种会更好。最后还是决定使用条件变量，主要原因如下：

     - 信号量和条件变量的效果是十分相似的。但我们可以发现，人们常常在进程间通信中使用信号量，在多线程同步中使用条件变量。这仅仅是因为习惯使然吗？我认为是条件变量在线程间通信的表现更为优秀
     - 用条件变量+互斥锁可以轻松的实现信号量，也就是说条件变量是包括信号量的
     - 条件变量可使用的`notify_all`全部唤醒功能是信号量不好实现的，而这在线程池析构时很好用
     - 在条件变量被唤醒时，不一定要对临界区的值进行修改；而信号量只要被唤醒，就一定会进行PV操作
     - 使用条件变量，可以自定义多种唤醒条件，可以在任意情况下唤醒条件变量；而信号量的唤醒一定需要PV操作
     - 以上是功能上的差别，可以发现条件变量更优。那么效率上呢？我没有找到确定的答案，网上的说法也众说纷纭。至于为什么不自己测试一下，我认为编写一个科学的效率评测程序是相当困难的。但可以确定的是，效率上的差别不会特别大，至少不是数量级上的差别

     综上所述，我们可以认为信号量其实可以算是一种对于条件变量的封装，使用信号量的话可以简化代码，而且信号量尤其适合生产者—消费者模型。但条件变量更灵活，有更多使用方式，我认为学习条件变量是一种更加通用方式，所以还是认为在多线程的程序设计中，使用条件变量是一种更加好的行为。（个人想法）

   - 第二点是对于阻塞队列中任务函数的编写方式，当然我可以写一个耦合性很高的专用于本项目的线程池，但我还是决定写了一个这样的通用线程池。主要的手法就是泛型编程，应该都是模板的基本操作，但我也从中学习到不少处理模板的技法，尤其是对于仿函数、类型推导以及可变参数模版等c++11特性。

   - 第三点是关于析构的设计。首先，线程池并没有采用单例模式，那么对于线程池的析构是必要的。然后是对于创建的子线程是否选择detach，由于我这里子线程的运行是依赖于线程池的成员变量，所以子线程必须在线程池析构前析构，所以我这里在线程池的析构函数中join所有的子线程。如果一定想写一个detach子线程的线程池，那么可以new一个结构体来保存所有需要的成员变量，然后所有的子线程都拥有一个指向该结构体的智能指针，这样线程池析构后子线程也能继续运行。但我还是认为，将所有子线程回收是更好的行为，而且这样方便我对线程池进行测试，在线程池析构后，说明所有子线程也都完成任务了。

3. To-do-list

   目前这个线程池还不支持对子线程数量的自动管理，但还是留了一些伏笔，这边将increase函数独立出来而不是放进构造函数就是为了以后可能需要增减线程数，现在这个increase还是线程不安全的，所以我暂时设为private。

   
