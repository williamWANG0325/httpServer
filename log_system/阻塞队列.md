# 关于阻塞队列

（以下想法不保证正确性）

1. 设计意图与思路

   - 设计阻塞队列这个类，是因为我在这个项目中已经第三次使用它了，这里相当于把我写的线程池中使用的队列抽象出来成为一个阻塞队列的类，然后提供给我的日志系统使用。凡是生产者—消费者模型，就一定会使用到阻塞队列，这个类虽然简单，但使用率很高，所以我希望写一个通用的版本。

   - 关于生产者—消费者模型主要有四种情况：一对一，一对多，多对一以及多对多。那么只要完成多对多的版本，自然也能适配其他的情况（所谓多对多就是多个生产者线程和多个消费者线程同时拥有一个阻塞队列）。另外，既然是通用的版本，所以使用了template来作为队列中的任务。

   - 在设计的初期，我其实是希望通过对`std::queue`进行封装来写一个线程安全的队列。即在类中保有一个`std::queue`对象和互斥锁，然后通过`std::queue`对象加锁来编写`pop()`、`push()`、`front()`、`empty()`等函数，但当我完成后就发现这样的想法问题很大。

   - 首先，我们应该明确，这个阻塞队列是为了服务于生产者—消费者模型的，而且这个队列是在多对多的版本下使用。那么这就会带来两个问题：

     1. 阻塞特性没有显现。
        - 应该来说，阻塞队列与`std::queue`应该是完全不同的两个东西，阻塞队列的要点在于阻塞。对于空的`std::queue`调用`front()、pop()`应该是一个违法行为，而对于阻塞队列则不然，对空的阻塞队列调用`get()`只是会导致该线程阻塞，所以我前面的想法从开始就是错误的。
        - 要实现阻塞很简单，通过条件变量`std::condition_variable`以及它拥有的函数`wait`和`notify_one`就能做到。

     2. 多对多情况下`front()、pop()`是线程不安全的。

        - 是的，即使他们本身是线程安全的，放在一起使用就是线程不安全的。对于`std::queue`，我们常常会一起使用`front()、pop()`，获取队列首部元素后弹出该元素，这在单线程环境下当然没问题。但在多线程环境下就不行，考虑两个消费者线程A、B先后访问队首元素，A在获取元素后还没来得及`pop()`，B也获取了队首元素，这样两个线程访问同一个元素再各自`pop()`就发生了`race condition`。

        - 解决这个问题也很简单，将`front()、pop()`函数合二为一成一个`get()`函数，并确保该函数线程安全，这样就完美解决了。
        - 那么这么做是否会导致功能的缺失呢？如果这么想的话说明你还在把阻塞队列与队列联系在一起，虽然阻塞队列的底层数据结构是队列没错，但其实完全不同。考虑生产者—消费者模型，该模型中`front()`函数完全是多余的，消费者做的事只有从队列中获取任务，然后弹出任务。
        - 注意，网上很多用于日志系统的阻塞队列都封装了`front()、pop()`函数，这不代表他们是错的，因为日志系统往往只有一个线程进行日志的写，即只有一个消费者（多对一），那么对于`front()、pop()`函数的访问是单线程的，这样是没问题。但是如果不是日志系统而是其他的情况（比如线程池这种多对多的），那么就可能会有问题。而且就我的理解，生产者—消费者模型根本不需要单独的`front()`函数，在该模型中`front()、pop()`函数本身就是绑定使用的，所以统一为`get()`应该是一个更好的写法。(我这里的个人理解不保证正确性，但至少在这个项目中是用不到的)。

   - 解决以上的问题，基本上算设计出了一个的阻塞队列，真的很简单，只要大概40行代码就能写出了这个类，只有两个函数:`push()`用于生产者放入任务，`get()`用于消费者取出任务。事实上一个完备的阻塞队列其实最好再加上重载的`push()、get()`函数,可以用来指定阻塞时间，但原理基本相同，而且我这个项目中用不到，所以就没写了。

2. 编写代码中遇到的问题与设计改进

   解决了初步设计问题，我很快写好了阻塞队列的代码（毕竟只有40行），接着兴冲冲跑去测试，结果就是经典写代码5分钟debug5小时。下面讲讲我在编写代码中遇到的问题以及一些经验教训。

   1. 关于多线程debug中的`fflush()`函数。

      - 进行测试的程序一运行就阻塞了，然后我尝试使用打印信息的方式，找到出问题的地方，再gdb调试。结果发现阻塞的程序根本不会打印信息，即使在`main()`函数的开始打印都没有，gdb调试也没有用。最后发现是输出缓冲区的问题，在这种多线程debug过程中，`printf`或`cout`后要加一句`fflush(stdout)`来强制刷新缓冲区。
   2. 关于析构。
      - 通过打印信息+gdb调试，我找到了问题：根本无法析构这个生产者模型。
      - 现在假设我在一个线程池中使用这个阻塞队列，即多对多模型，同时我们规定：在线程池析构时，我们需要回收所有的子线程，同时保证队列中所有的任务已经被执行完。（为什么这样规定可以看看我对线程池的总结）
      - 这样的话，我们可以发现，这个线程池是不可能回收消费者线程的，消费者线程在清空阻塞队列后会一直阻塞在阻塞队列的`get()`中，根本无法回收。那么解决的方法就是：在阻塞队列中增加一个`alive`成员标志阻塞队列的状态；然后再加入一个函数`destoryNow()`来负责将`alive`成员设置为`false`并唤醒所有子线程；最后在`push()、get()`函数中添加对于`alive = false`情况的响应。这样只要在线程池回收子进程之前，先调用一次阻塞队列的`destoryNow()`，就不会出现上述的情况。（具体实现方式可以看看代码）
      - 虽然上面的办法确实解决了问题。但这并不能算一个好的解决方法。可以发现，我们需要使用阻塞队列的生产者—消费者模型在析构函数中先调用它的成员函数，这样的做法是很反直觉的，如果不知道阻塞队列的内部结构，是无法理解这种要求的。如果别人使用我写的阻塞队列，那么他很可能忘记在析构时调用`destoryNow()`。但是目前我也没有想到好的解决办法，如果以后想到了，再来更新。
   
2. 总结体会

   最终版阻塞队列代码只有50行，但是我却花费了大量的时间。会出现这种情况呢，我想主要有两个原因：

   - 阻塞队列的设计我是基于对`stl::queue`的模仿而不是实际使用情况，这使得我在设计时保有很多定向思维，总想仿造`stl::queue`的写法，最终出现很多没意义的函数。所以，对于类的设计一定要参照实际情况。
- 因为参照我自己写的线程池抽象出阻塞队列这个类，所以对析构这一块的设计出现问题。在多线程编程中，对于对象的析构一定要特别注意。我总结出的经验是，使用一个`alive`成员来标志类本身的状态是一个很有意义的做法，这往往可以在析构函数中发挥很大的作用。